package sqloracle

import (
	"database/sql"
	"errors"
	"fmt"
	"regexp"
	"strings"

	"github.com/duke-git/lancet/v2/slice"
	. "github.com/fj1981/infrakit/pkg/cydb"
	"github.com/fj1981/infrakit/pkg/cyutil"
)

func (s *oracleSql) GetDDLSqlFunc(funcName DDLSqlFuncName) (DDLSqlFunc, error) {
	switch funcName {
	case FuncNameGetCreateTableSql:
		return func(cli DatabaseClient, tableName ...string) (*SqlContent, error) {
			db, table := GetDBAndTable(cli, tableName...)
			if table == "" {
				return nil, errors.New("table name is empty")
			}
			ret, err := s.getCreateTableSQL(cli, db, table)
			if err != nil {
				return nil, err
			}
			return &SqlContent{Name: table, Content: ret}, nil
		}, nil
	case FuncNameGetCreateViewSql:
		return func(cli DatabaseClient, viewName ...string) (*SqlContent, error) {
			db, view := GetDBAndTable(cli, viewName...)
			if view == "" {
				return nil, errors.New("view name is empty")
			}
			ret, err := s.getCreateViewSql(cli, db, view)
			if err != nil {
				return nil, err
			}
			return &SqlContent{Name: view, Content: ret}, nil
		}, nil
	case FuncNameGetCreateProcedureSql:
		return func(cli DatabaseClient, procName ...string) (*SqlContent, error) {
			db, proc := GetDBAndTable(cli, procName...)
			if proc == "" {
				return nil, errors.New("procedure name is empty")
			}
			ret, err := s.getCreateProcedureSql(cli, db, proc)
			if err != nil {
				return nil, err
			}
			return &SqlContent{Name: proc, Content: ret}, nil
		}, nil
	case FuncNameGetCreateFunctionSql:
		return func(cli DatabaseClient, funcName ...string) (*SqlContent, error) {
			db, func_ := GetDBAndTable(cli, funcName...)
			if func_ == "" {
				return nil, errors.New("function name is empty")
			}
			ret, err := s.getCreateFunctionSql(cli, db, func_)
			if err != nil {
				return nil, err
			}
			return &SqlContent{Name: func_, Content: ret}, nil
		}, nil
	case FuncNameGetTableEventSql:
		return func(cli DatabaseClient, eventName ...string) (*SqlContent, error) {
			db, event := GetDBAndTable(cli, eventName...)
			if event == "" {
				return nil, errors.New("event name is empty")
			}
			ret, err := s.GetCreateEventSql(cli, db, event)
			if err != nil {
				return nil, err
			}
			return &SqlContent{Name: event, Content: ret}, nil
		}, nil
	case FuncNameGetBeginSql:
		return func(cli DatabaseClient, name ...string) (*SqlContent, error) {
			db, _ := GetDBAndTable(cli, name...)
			db = strings.ToUpper(db)
			sql := fmt.Sprintf(`
CREATE OR REPLACE FUNCTION %s.DECODE_BASE64 (p_base64_string IN VARCHAR2)
RETURN VARCHAR2 IS
    v_decoded_raw RAW(4000);
    v_decoded_string VARCHAR2(4000);
BEGIN
    v_decoded_raw := UTL_ENCODE.BASE64_DECODE(UTL_RAW.CAST_TO_RAW(p_base64_string));
    v_decoded_string := UTL_RAW.CAST_TO_VARCHAR2(v_decoded_raw);
    RETURN v_decoded_string;
END;
/

`, db)
			return &SqlContent{Name: "DECODE_BASE64", Content: sql}, nil
		}, nil
	case FuncNameGetEndSql:
		return func(cli DatabaseClient, name ...string) (*SqlContent, error) {
			db, _ := GetDBAndTable(cli, name...)
			db = strings.ToUpper(db)
			return &SqlContent{Name: "Final", Content: fmt.Sprintf(`
DECLARE
  v_schema   VARCHAR2(30) := '%s';
  CURSOR c_identity IS 
    SELECT table_name, column_name
    FROM all_tab_identity_cols
    WHERE owner = UPPER(v_schema)
      AND table_name NOT LIKE 'BIN$%%' ESCAPE '\';
  v_sql       VARCHAR2(32767);
  v_max_id    NUMBER;
BEGIN
  FOR rec IN c_identity LOOP
    BEGIN
      -- 获取当前最大ID
      EXECUTE IMMEDIATE 
        'SELECT NVL(MAX(' || rec.column_name || '), 0) FROM ' || v_schema || '.' || rec.table_name
      INTO v_max_id;

      -- 构造 ALTER TABLE 语句（使用 GENERATED BY DEFAULT 兼容已有数据）
      v_sql := 'ALTER TABLE ' || v_schema || '.' || rec.table_name || 
               ' MODIFY ' || rec.column_name || 
               ' GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH ' || (v_max_id + 1) || ')';

      EXECUTE IMMEDIATE v_sql;

      -- 可选：输出日志
      DBMS_OUTPUT.PUT_LINE('Reset identity on ' || rec.table_name || '.' || rec.column_name || ' to START WITH ' || (v_max_id + 1));

    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Failed on ' || rec.table_name || '.' || rec.column_name || ': ' || SQLERRM);
    END;
  END LOOP;
END;
/`, db)}, nil
		}, nil
	default:
		return nil, nil
	}
}

// ColumnInfo 表字段信息
type ColumnInfo struct {
	ColumnName    string         `db:"COLUMN_NAME"`
	DataType      string         `db:"DATA_TYPE"`
	DataLength    sql.NullInt64  `db:"DATA_LENGTH"`
	CharLength    sql.NullInt64  `db:"CHAR_LENGTH"`
	DataPrecision sql.NullInt64  `db:"DATA_PRECISION"`
	DataScale     sql.NullInt64  `db:"DATA_SCALE"`
	Nullable      string         `db:"NULLABLE"`
	CharUsed      sql.NullString `db:"CHAR_USED"`
	DataDefault   sql.NullString `db:"DATA_DEFAULT"`
}

// ConstraintInfo 约束信息
type ConstraintInfo struct {
	ConstraintName  string         `db:"CONSTRAINT_NAME"`
	ConstraintType  string         `db:"CONSTRAINT_TYPE"` // 'P':主键, 'R':外键, 'U':唯一, 'C':检查
	ColumnName      string         `db:"COLUMN_NAME"`
	Position        *int           `db:"POSITION"`
	RConstraintName sql.NullString `db:"R_CONSTRAINT_NAME"`
	DeleteRule      sql.NullString `db:"DELETE_RULE"`
	SearchCondition sql.NullString `db:"SEARCH_CONDITION"`
}

// CommentInfo 字段注释
type CommentInfo struct {
	ColumnName string `db:"COLUMN_NAME"`
	Comments   string `db:"COMMENTS"`
}

// TriggerInfo 触发器
type TriggerInfo struct {
	TriggerName  string `db:"TRIGGER_NAME"`
	TriggerType  string `db:"TRIGGER_TYPE"`
	TriggerEvent string `db:"TRIGGER_EVENT"`
	TriggerBody  string `db:"TRIGGER_BODY"`
}

// IndexInfo 索引信息
type IndexInfo struct {
	IndexName      string `db:"INDEX_NAME"`
	ColumnName     string `db:"COLUMN_NAME"`
	ColumnPosition int    `db:"COLUMN_POSITION"`
	Uniqueness     string `db:"UNIQUENESS"`
	Descend        string `db:"DESCEND"` // ASC or DESC
}

// RefConstraintInfo 用于存储外键引用的约束信息
type RefConstraintInfo struct {
	RConstraintName string `db:"R_CONSTRAINT_NAME"`
	TableName       string `db:"TABLE_NAME"`
	Owner           string `db:"OWNER"`
}

// ColumnExpressionInfo 列表达式
type ColumnExpressionInfo struct {
	ColumnName       string `db:"COLUMN_NAME"`
	IndexName        string `db:"INDEX_NAME"`
	ColumnExpression string `db:"COLUMN_EXPRESSION"`
}

// GetCreateTableSQL 从 Oracle 数据库反向生成建表语句
func (s *oracleSql) getCreateTableSQL(cli DatabaseClient, schemaOwner, tableName string) (string, error) {
	tableName = ConvertReservedKeywords(tableName)
	tableName = strings.ToUpper(tableName)
	schemaOwner = strings.ToUpper(schemaOwner)
	// 1. 获取字段信息
	columns, err := getColumns(cli, schemaOwner, tableName)
	if err != nil {
		return "", err
	}
	if len(columns) == 0 {
		return "", nil
	}
	// 2. 获取约束信息
	constraints, err := getConstraints(cli, schemaOwner, tableName)
	if err != nil {
		return "", err
	}

	// 3. 获取字段注释
	comments, err := getComments(cli, schemaOwner, tableName)
	if err != nil {
		return "", err
	}

	// 4. 获取索引信息
	indexes, err := getIndexes(cli, schemaOwner, tableName)
	if err != nil {
		return "", err
	}

	// 5. 获取列表达式
	expressions, err := getColumnExpression(cli, schemaOwner, tableName)
	if err != nil {
		return "", err
	}

	// ====== 开始拼接 SQL ======

	// CREATE TABLE
	createSql := fmt.Sprintf("\nCREATE TABLE \"%s\".\"%s\" (\n\t", schemaOwner, tableName)

	// 字段定义
	var colAndConstraintDefs []string
	primaryKeyCols := []string{}
	uniqueConstraints := make(map[string][]string) // constraint_name -> columns
	foreignKeyMap := make(map[string]struct {
		Columns         []string
		RConstraintName string
	}) // constraint_name -> {columns, r_constraint_name}
	checkConstraints := make(map[string]string) // constraint_name -> condition

	// 创建列名到注释的映射
	columnComments := make(map[string]string)
	hasComments := false
	for _, cmt := range comments {
		if cmt.Comments != "" {
			columnComments[cmt.ColumnName] = cmt.Comments
			hasComments = true
		}
	}
	columnNameMap := make(map[string]struct{})

	for _, col := range columns {
		columnNameMap[col.ColumnName] = struct{}{}
		def := "    \"" + col.ColumnName + "\"" + " " + buildDataType(col)

		if col.DataDefault.Valid && col.DataDefault.String != "" {
			// 使用substractDefault函数处理默认值
			defaultVal := s.substractDefault(col.DataDefault)
			uDefaultVal := strings.ToUpper(defaultVal)
			if strings.Contains(uDefaultVal, ".NEXTVAL") && strings.Contains(uDefaultVal, "\""+schemaOwner+"\"") {
				def += " GENERATED BY DEFAULT ON NULL AS IDENTITY"
			} else {
				def += fmt.Sprintf(" DEFAULT %s", defaultVal)
			}

		}

		if col.Nullable == "N" {
			def += " NOT NULL"
		}
		colAndConstraintDefs = append(colAndConstraintDefs, def)
	}

	funcKeepExistColumns := func(v []string) []string {
		r := make([]string, 0)
		for _, col := range v {
			if _, ok := columnNameMap[col]; ok {
				r = append(r, col)
			}
		}
		return r
	}

	// 处理约束
	for _, cons := range constraints {
		switch cons.ConstraintType {
		case "P":
			primaryKeyCols = append(primaryKeyCols, cons.ColumnName)
		case "U":
			uniqueConstraints[cons.ConstraintName] = append(uniqueConstraints[cons.ConstraintName], cons.ColumnName)
		case "R":
			fk := foreignKeyMap[cons.ConstraintName]
			fk.Columns = append(fk.Columns, cons.ColumnName)
			if cons.RConstraintName.Valid {
				fk.RConstraintName = cons.RConstraintName.String
			}
			foreignKeyMap[cons.ConstraintName] = fk
		case "C":
			if cons.SearchCondition.Valid {
				checkConstraints[cons.ConstraintName] = cons.SearchCondition.String
			}
		}
	}
	mapUnique := make(map[string]struct{})
	// 主键
	primaryKeyCols = funcKeepExistColumns(primaryKeyCols)
	if len(primaryKeyCols) > 0 {
		// 使用更安全的主键命名方式，避免名称过长
		pkName := "PK_" + tableName
		if len(pkName) > 30 {
			// Oracle标识符最大长度为30个字符
			pkName = "PK_" + tableName[:22] + "_" + cyutil.NanoID(4)
		}
		pkCols := slice.Unique(primaryKeyCols)
		slice.Sort(pkCols)
		mapUnique[strings.Join(pkCols, "_")] = struct{}{}
		// 将列名添加双引号
		quotedPKCols := make([]string, len(pkCols))
		for i, col := range pkCols {
			quotedPKCols[i] = "\"" + col + "\""
		}
		colAndConstraintDefs = append(colAndConstraintDefs, fmt.Sprintf("    CONSTRAINT \"%s\" PRIMARY KEY (%s)", pkName, strings.Join(quotedPKCols, ", ")))
	}

	// 唯一约束
	for consName, cols := range uniqueConstraints {
		cols = funcKeepExistColumns(cols)
		if len(cols) == 0 {
			continue
		}

		uniqueCols := slice.Unique(cols)
		// 将列名添加双引号
		quotedCols := make([]string, len(uniqueCols))
		slice.Sort(uniqueCols)
		mapUnique[strings.Join(uniqueCols, "_")] = struct{}{}
		for i, col := range uniqueCols {
			quotedCols[i] = "\"" + col + "\""
		}
		colAndConstraintDefs = append(colAndConstraintDefs, fmt.Sprintf("    CONSTRAINT \"%s\" UNIQUE (%s)", consName, strings.Join(quotedCols, ", ")))
	}

	// 外键约束 - 补全引用表名
	for consName, fk := range foreignKeyMap {
		// 查询引用约束对应的表名和列名
		refTableInfo, err := getRefConstraintInfo(cli, schemaOwner, fk.RConstraintName)
		if err != nil {
			return "", fmt.Errorf("failed to get referenced table for constraint %s: %v", consName, err)
		}

		refTable := refTableInfo.TableName
		refOwner := refTableInfo.Owner
		if refTable == "" {
			refTable = "UNKNOWN_TABLE"
		}
		if refOwner == "" {
			refOwner = schemaOwner
		}

		// 获取引用表的主键列名
		refCols, err := getRefConstraintColumns(cli, schemaOwner, fk.RConstraintName)
		if err != nil {
			refCols = []string{"ID"} // 默认值
		}

		// 构建外键约束语句，包含删除规则
		// 将外键列名添加双引号
		fkCols := slice.Unique(fk.Columns)
		quotedFKCols := make([]string, len(fkCols))
		for i, col := range fkCols {
			quotedFKCols[i] = "\"" + col + "\""
		}

		// 将引用列名添加双引号
		quotedRefCols := make([]string, len(refCols))
		for i, col := range refCols {
			quotedRefCols[i] = "\"" + col + "\""
		}

		fkSQL := fmt.Sprintf("    CONSTRAINT \"%s\" FOREIGN KEY (%s) REFERENCES \"%s\".\"%s\"(%s)",
			consName, strings.Join(quotedFKCols, ", "), refOwner, refTable, strings.Join(quotedRefCols, ", "))

		// 添加删除规则
		/*
			if cons, ok := slice.Find(constraints, func(index int, c ConstraintInfo) bool {
				return c.ConstraintName == consName && c.DeleteRule.Valid
			}); ok && cons.DeleteRule.Valid {
				fkSQL += " ON DELETE " + cons.DeleteRule.String
			}
		*/
		colAndConstraintDefs = append(colAndConstraintDefs, fkSQL)
	}

	// 检查约束
	for consName, cond := range checkConstraints {
		// 将CHECK约束中的列名添加双引号
		// 匹配列名模式：列名后面跟着空格和操作符
		modifiedCond := cond
		for _, col := range columns {
			// 如果列名已经被引号包围，则跳过
			if strings.Contains(modifiedCond, "\""+col.ColumnName+"\"") {
				continue
			}
			// 将未引用的列名替换为引用形式
			// 使用正则表达式确保只替换完整的列名
			re := regexp.MustCompile(`(^|[^\w"])` + regexp.QuoteMeta(col.ColumnName) + `($|[^\w"])`)
			modifiedCond = re.ReplaceAllString(modifiedCond, "${1}\""+col.ColumnName+"\"${2}")
		}
		colAndConstraintDefs = append(colAndConstraintDefs, fmt.Sprintf("    CONSTRAINT \"%s\" CHECK (%s)", consName, modifiedCond))
	}
	createSql += strings.Join(colAndConstraintDefs, ",\n") + "\n)\n"

	columnCexpressions := make(map[string]ColumnExpressionInfo)
	for _, expr := range expressions {
		columnCexpressions[expr.ColumnName] = expr
	}
	indexSql := []string{}
	if len(indexes) > 0 {
		indexMap := make(map[string]struct {
			Columns    []string
			Uniqueness string
		})
		for _, idx := range indexes {
			key := idx.IndexName
			if _, exists := indexMap[key]; !exists {
				indexMap[key] = struct {
					Columns    []string
					Uniqueness string
				}{Uniqueness: idx.Uniqueness}
			}
			// Fix: Get the struct, modify it, then put it back
			entry := indexMap[key]
			entry.Columns = append(entry.Columns, idx.ColumnName)
			indexMap[key] = entry
		}

		for name, idx := range indexMap {
			cols := idx.Columns
			cols = funcKeepExistColumns(cols)
			if len(cols) == 0 {
				continue
			}
			isUnique := ""
			cols = slice.Unique(cols)
			if idx.Uniqueness == "UNIQUE" {
				isUnique = "UNIQUE "
				slice.Sort(cols)
				key := strings.Join(cols, "_")
				if _, ok := mapUnique[key]; ok {
					continue
				}
				mapUnique[key] = struct{}{}
			}
			quotedIdxCols := make([]string, len(cols))
			for i, col := range cols {
				if v, ok := columnCexpressions[col]; ok {
					quotedIdxCols[i] = v.ColumnExpression
				} else {
					quotedIdxCols[i] = "\"" + col + "\""
				}
			}
			indexSql = append(indexSql, fmt.Sprintf("CREATE %sINDEX \"%s\" ON \"%s\".\"%s\" (%s)", isUnique, name, schemaOwner, tableName, strings.Join(quotedIdxCols, ", ")))
		}
	}

	for i, indexSql2 := range indexSql {
		indexSql[i] = WrapperSqlIngoreExist(indexSql2)
	}

	triggers, err := s.getCreateTriggerSql(cli, schemaOwner, tableName)
	if err != nil {
		return "", err
	}
	createSql = WrapperSqlIngoreExist(createSql)
	if createSql != "" {
		createSql += "\n"
	}
	var indexSqls string
	if len(indexSql) != 0 {
		indexSqls = strings.Join(indexSql, "\n")
		indexSqls += "\n"
	}
	var triggerSqls string
	if len(triggers) != 0 {
		triggerSqls = strings.Join(triggers, "\n")
		triggerSqls += "\n"
	}
	// 生成注释语句
	var commentSqls string
	if hasComments {
		var commentStmts []string
		for _, col := range columns {
			if comment, exists := columnComments[col.ColumnName]; exists && comment != "" {
				// 转义单引号
				escapedComment := strings.ReplaceAll(comment, "'", "''")
				commentStmt := fmt.Sprintf("COMMENT ON COLUMN \"%s\".\"%s\".\"%s\" IS '%s';",
					schemaOwner, tableName, col.ColumnName, escapedComment)
				commentStmts = append(commentStmts, commentStmt)
			}
		}
		if len(commentStmts) > 0 {
			commentSqls = strings.Join(commentStmts, "\n") + "\n"
		}
	}

	finalSql := fmt.Sprintf("%s%s%s%s", createSql, indexSqls, triggerSqls, commentSqls)
	return finalSql, nil
}

func getColumns(cli DatabaseClient, schemaOwner, tableName string) ([]ColumnInfo, error) {
	var cols []ColumnInfo
	query := `
		SELECT 
			COLUMN_NAME, 
			DATA_TYPE, 
			DATA_LENGTH, 
			DATA_PRECISION, 
			DATA_SCALE, 
			CHAR_LENGTH,
			CHAR_USED,
			NULLABLE, 
			DATA_DEFAULT
		FROM ALL_TAB_COLUMNS 
		WHERE OWNER = :1    
		AND TABLE_NAME = :2
		ORDER BY COLUMN_ID`
	err := cli.Select(&cols, query, schemaOwner, tableName)
	return cols, err
}

func getConstraints(cli DatabaseClient, schemaOwner, tableName string) ([]ConstraintInfo, error) {
	var cons []ConstraintInfo
	query := `
SELECT 
    ac.CONSTRAINT_NAME, 
    ac.CONSTRAINT_TYPE, 
    acc.COLUMN_NAME, 
    acc.POSITION,
    ac.R_CONSTRAINT_NAME, 
    ac.DELETE_RULE,
    ac.SEARCH_CONDITION
FROM 
    ALL_CONSTRAINTS ac
JOIN 
    ALL_CONS_COLUMNS acc 
    ON ac.CONSTRAINT_NAME = acc.CONSTRAINT_NAME 
	AND ac.TABLE_NAME = acc.TABLE_NAME
	AND ac.OWNER = acc.OWNER
WHERE 
    ac.TABLE_NAME = :1
    AND ac.OWNER = :2
	AND (ac.CONSTRAINT_NAME NOT LIKE 'SYS_%' OR ac.CONSTRAINT_TYPE = 'P')
ORDER BY 
    acc.POSITION`

	err := cli.Select(&cons, query, tableName, schemaOwner)
	return cons, err
}

func getComments(cli DatabaseClient, schemaOwner, tableName string) ([]CommentInfo, error) {
	var comments []CommentInfo
	query := `
		SELECT COLUMN_NAME, COMMENTS 
			FROM ALL_COL_COMMENTS 
			WHERE TABLE_NAME = :1
			AND OWNER = :2
			AND COMMENTS IS NOT NULL`
	err := cli.Select(&comments, query, tableName, schemaOwner)
	return comments, err
}

func getColumnExpression(cli DatabaseClient, schemaOwner, tableName string) ([]ColumnExpressionInfo, error) {
	var cols []ColumnExpressionInfo
	query := `
	SELECT 
		ic.COLUMN_NAME,
		ic.INDEX_NAME,
		ie.COLUMN_EXPRESSION
	FROM 
		dba_ind_columns ic
	JOIN 
		dba_ind_expressions ie 
		ON ic.INDEX_NAME = ie.INDEX_NAME AND ic.COLUMN_POSITION=ie.COLUMN_POSITION
	WHERE 
		ic.TABLE_OWNER = :1
		AND ic.TABLE_NAME = :2`
	err := cli.Select(&cols, query, schemaOwner, tableName)
	return cols, err
}

func getIndexes(cli DatabaseClient, schemaOwner, tableName string) ([]IndexInfo, error) {
	var indexes []IndexInfo
	query := `
		SELECT 
			ui.INDEX_NAME,
			uic.COLUMN_NAME,
			uic.COLUMN_POSITION,
			ui.UNIQUENESS,
			uic.DESCEND
		FROM ALL_INDEXES ui
		JOIN ALL_IND_COLUMNS uic ON ui.INDEX_NAME = uic.INDEX_NAME
		WHERE ui.TABLE_NAME = :1
		AND ui.OWNER = :2
		AND ui.INDEX_NAME NOT LIKE 'SYS_%'
		ORDER BY ui.INDEX_NAME, uic.COLUMN_POSITION`
	err := cli.Select(&indexes, query, tableName, schemaOwner)
	return indexes, err
}

// getRefTableName 根据引用约束名获取对应的表名
// getRefConstraintInfo 获取引用约束的表信息
func getRefConstraintInfo(cli DatabaseClient, schemaOwner, rConstraintName string) (RefConstraintInfo, error) {
	var refInfo RefConstraintInfo
	// 查询全表，使用 owner 进行限制
	query := `
		SELECT uc.TABLE_NAME, uc.OWNER
		FROM ALL_CONSTRAINTS uc
		WHERE uc.CONSTRAINT_NAME = :1
		AND uc.OWNER = :2`
	err := cli.Get(&refInfo, query, rConstraintName, schemaOwner)
	if err != nil {
		if err == sql.ErrNoRows {
			return RefConstraintInfo{}, nil // 约束不存在
		}
		return RefConstraintInfo{}, err
	}
	return refInfo, nil
}

// getRefConstraintColumns 获取引用约束的列信息
func getRefConstraintColumns(cli DatabaseClient, schemaOwner, rConstraintName string) ([]string, error) {
	// 查询全表，使用 owner 进行限制
	query := `
		SELECT acc.COLUMN_NAME
		FROM ALL_CONS_COLUMNS acc
		JOIN ALL_CONSTRAINTS ac ON acc.CONSTRAINT_NAME = ac.CONSTRAINT_NAME AND acc.OWNER = ac.OWNER
		WHERE ac.CONSTRAINT_NAME = :1
		AND ac.OWNER = :2
		ORDER BY acc.POSITION`

	rows, err := cli.Query(query, rConstraintName, schemaOwner)
	if err != nil {
		return nil, err
	}

	var columns []string
	for _, row := range rows {
		if colName, ok := row["COLUMN_NAME"].(string); ok {
			columns = append(columns, colName)
		}
	}

	return columns, nil
}

type Trigger struct {
	Owner            string         `db:"OWNER"`
	TriggerName      string         `db:"TRIGGER_NAME"`
	TriggerType      string         `db:"TRIGGER_TYPE"`
	TriggeringEvent  string         `db:"TRIGGERING_EVENT"`
	TableOwner       string         `db:"TABLE_OWNER"`
	BaseObjectType   string         `db:"BASE_OBJECT_TYPE"`
	TableName        string         `db:"TABLE_NAME"`
	ColumnName       sql.NullString `db:"COLUMN_NAME"`
	ReferencingNames string         `db:"REFERENCING_NAMES"`
	WhenClause       sql.NullString `db:"WHEN_CLAUSE"`
	Status           string         `db:"STATUS"`
	Description      string         `db:"DESCRIPTION"`
	ActionType       string         `db:"ACTION_TYPE"`
	TriggerBody      string         `db:"TRIGGER_BODY"`
	Crosession       string         `db:"CROSSEDITION"`
	BeforeStatement  string         `db:"BEFORE_STATEMENT"`
	BeforeRow        string         `db:"BEFORE_ROW"`
	AfterRow         string         `db:"AFTER_ROW"`
	AfterStatement   string         `db:"AFTER_STATEMENT"`
	InsteadOfRow     string         `db:"INSTEAD_OF_ROW"`
	FireOnce         string         `db:"FIRE_ONCE"`
	ApplyServerOnly  string         `db:"APPLY_SERVER_ONLY"`
}

type SequenceInfo struct {
	SequenceName  string `db:"SEQUENCE_NAME"`
	MinValue      string `db:"MIN_VALUE"`
	MaxValue      string `db:"MAX_VALUE"`
	IncrementBy   string `db:"INCREMENT_BY"`
	CycleFlag     string `db:"CYCLE_FLAG"`
	OrderFlag     string `db:"ORDER_FLAG"`
	CacheSize     string `db:"CACHE_SIZE"`
	LastNumber    string `db:"LAST_NUMBER"`
	SequenceOwner string `db:"SEQUENCE_OWNER"`
}

func getOracleTrigger(cli DatabaseClient, schemaOwner, tableName string) ([]string, error) {
	// 查询触发器信息
	var triggers []Trigger
	query := `
	SELECT 
		OWNER, TRIGGER_NAME, TRIGGER_TYPE, TRIGGERING_EVENT, TABLE_OWNER, 
		BASE_OBJECT_TYPE, TABLE_NAME, COLUMN_NAME, REFERENCING_NAMES, 
		WHEN_CLAUSE, STATUS, DESCRIPTION, ACTION_TYPE, TRIGGER_BODY, 
		CROSSEDITION, BEFORE_STATEMENT, BEFORE_ROW, AFTER_ROW, 
		AFTER_STATEMENT, INSTEAD_OF_ROW, FIRE_ONCE, APPLY_SERVER_ONLY
	FROM ALL_TRIGGERS
	WHERE TABLE_NAME = :1 AND TABLE_OWNER = :2
	`
	err := cli.Select(&triggers, query, tableName, schemaOwner)
	if err != nil {
		return nil, err
	}

	result := []string{}

	// 遍历触发器信息并拼接 SQL 创建语句
	for _, trigger := range triggers {
		sequenceNames := extractSequenceNamesFromTriggerBody(trigger.TriggerBody)
		if len(sequenceNames) != 0 {
			seq, err := getOracleSequence(cli, schemaOwner, sequenceNames)
			if err != nil {
				return nil, err
			}
			result = append(result, seq...)
		}
		timing, err := getTiming(trigger.TriggerType, trigger.TriggeringEvent, fmt.Sprintf("\"%s\".\"%s\"", trigger.TableOwner, trigger.TableName))
		if err != nil {
			return nil, err
		}
		createTriggerSQL := fmt.Sprintf("CREATE OR REPLACE TRIGGER \"%s\".\"%s\"\n%s\n%s\n/\n",
			trigger.Owner,
			trigger.TriggerName,
			timing,
			strings.TrimSpace(trigger.TriggerBody),
		)
		result = append(result, createTriggerSQL)
	}
	return result, nil
}

// 根据触发时机生成对应的 SQL 片段
func getTiming(triggerType string, triggerEvent string, tableName string) (string, error) {
	fieled := strings.Fields(triggerType)
	if len(fieled) < 3 {
		return "", errors.New("trigger type is empty")
	}
	result := []string{fieled[0]}
	switch fieled[0] {
	case "INSTEAD":
		result = append(result, fieled[1], triggerEvent, "ON", tableName, "FOR")
		result = append(result, fieled[2:]...)
	default:
		result = append(result, triggerEvent, "ON", tableName, "FOR")
		result = append(result, fieled[1:]...)
	}

	return strings.Join(result, " "), nil
}

// extractSequenceNamesFromTriggerBody 从触发器体中提取序列名称
func extractSequenceNamesFromTriggerBody(triggerBody string) []string {
	// 常见的序列模式，如 nextval, currval
	patterns := []string{
		`(\w+)\.nextval`,
		`(\w+)\.currval`,
		`nextval\s*\(\s*['"]\s*(\w+)\s*['"]`,
		`currval\s*\(\s*['"]\s*(\w+)\s*['"]`,
	}

	// 用于存储找到的序列名称，使用map去重
	sequenceMap := make(map[string]struct{})

	// 将触发器体转换为小写以便不区分大小写匹配
	lowerBody := strings.ToLower(triggerBody)

	// 对每个模式进行匹配
	for _, pattern := range patterns {
		// 使用正则表达式查找所有匹配项
		re := regexp.MustCompile(pattern)
		matches := re.FindAllStringSubmatch(lowerBody, -1)

		// 将找到的序列名添加到map中
		for _, match := range matches {
			if len(match) >= 2 {
				sequenceMap[match[1]] = struct{}{}
			}
		}
	}

	// 将map中的键转换为切片
	sequences := make([]string, 0, len(sequenceMap))
	for seq := range sequenceMap {
		sequences = append(sequences, seq)
	}

	return sequences
}

// getOracleSequence 根据序列名称查询序列信息并生成创建SQL
func getOracleSequence(cli DatabaseClient, schemaOwner string, sequenceNames []string) ([]string, error) {
	if len(sequenceNames) == 0 {
		return []string{}, nil
	}

	// 构建IN查询的参数
	params := make([]interface{}, len(sequenceNames)+1)
	params[0] = schemaOwner

	// 构建IN查询的占位符
	placeholders := make([]string, len(sequenceNames))
	for i, name := range sequenceNames {
		placeholders[i] = fmt.Sprintf(":p%d", i+1)
		params[i+1] = strings.ToUpper(name) // Oracle通常以大写存储对象名
	}

	// 查询序列信息
	var sequences []SequenceInfo
	query := fmt.Sprintf(`
	SELECT 
		SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY, 
		CYCLE_FLAG, ORDER_FLAG, CACHE_SIZE, LAST_NUMBER, SEQUENCE_OWNER
	FROM ALL_SEQUENCES
	WHERE SEQUENCE_OWNER = :1 AND SEQUENCE_NAME IN (%s)
	`, strings.Join(placeholders, ", "))

	err := cli.Select(&sequences, query, params...)
	if err != nil {
		return nil, fmt.Errorf("failed to query sequence info: %w", err)
	}

	// 如果没有找到任何序列，返回空结果
	if len(sequences) == 0 {
		return []string{}, nil
	}

	// 生成创建序列的SQL语句
	result := make([]string, len(sequences))
	for i, seq := range sequences {
		if seq.CacheSize == "0" || seq.CacheSize == "" {
			seq.CacheSize = "20"
		}
		// 构建CREATE SEQUENCE语句
		sql := fmt.Sprintf(`CREATE SEQUENCE "%s"."%s"
  MINVALUE %s
  MAXVALUE %s
  INCREMENT BY %s
  %s
  %s
  CACHE %s`,
			seq.SequenceOwner,
			seq.SequenceName,
			seq.MinValue,
			seq.MaxValue,
			seq.IncrementBy,
			ternary(seq.CycleFlag == "Y", "CYCLE", "NOCYCLE"),
			ternary(seq.OrderFlag == "Y", "ORDER", "NOORDER"),
			seq.CacheSize,
		)
		result[i] = WrapperSqlIngoreExist(sql)
	}

	return result, nil
}

// ternary 三元运算符辅助函数
func ternary(condition bool, trueVal, falseVal string) string {
	if condition {
		return trueVal
	}
	return falseVal
}

func (s *oracleSql) getCreateTriggerSql(j DatabaseClient, database, tableName string) ([]string, error) {
	tableName = ConvertReservedKeywords(tableName)

	return getOracleTrigger(j, database, tableName)
}

func fixedEnd(s string, slash ...bool) string {
	s = strings.TrimSpace(s)
	if !strings.HasSuffix(s, ";") {
		s += ";"
	}
	s += "\n"
	if len(slash) > 0 && slash[0] {
		s += "/\n"
	}
	return s
}

func removeEDITIONABLE(s string) string {
	// 只移除第一行中的 EDITIONABLE
	index1 := strings.Index(s, " EDITIONABLE ")
	if index1 == -1 {
		return s
	}
	index2 := strings.Index(s, "\n")
	if index2 == -1 || index2 >= index1 {
		return s[:index1] + s[index1+len(" EDITIONABLE"):]
	}
	return s

}

func (s *oracleSql) getCreateViewSql(j DatabaseClient, database, viewName string) (string, error) {
	viewName = ConvertReservedKeywords(viewName)
	// Query to get the view definition from Oracle data dictionary
	query := `
		SELECT DBMS_METADATA.GET_DDL('VIEW', :viewName, :schema) as ddl
		FROM DUAL
	`

	// Execute the query with parameters
	params := map[string]interface{}{
		"viewName": strings.ToUpper(viewName),
		"schema":   strings.ToUpper(database),
	}

	// Query the database
	result, err := j.NQuery(query, params)
	if err != nil {
		return "", err
	}

	// Check if we got any results
	if len(result) == 0 {
		return "", fmt.Errorf("view %s not found", viewName)
	}

	// Get the DDL from the result
	ddl, ok := result[0]["DDL"].(string)
	if !ok || ddl == "" {
		return "", fmt.Errorf("empty view definition for %s", viewName)
	}

	// Return the view DDL
	return fixedEnd(removeEDITIONABLE(ddl)), nil
}

func (s *oracleSql) getCreateProcedureSql(j DatabaseClient, database, procName string) (string, error) {
	procName = ConvertReservedKeywords(procName)
	// Query to get the procedure definition from Oracle data dictionary
	query := `
		SELECT DBMS_METADATA.GET_DDL('PROCEDURE', :procName, :schema) as ddl
		FROM DUAL
	`

	// Execute the query with parameters
	params := map[string]interface{}{
		"procName": strings.ToUpper(procName),
		"schema":   strings.ToUpper(database),
	}

	// Query the database
	result, err := j.NQuery(query, params)
	if err != nil {
		return "", err
	}

	// Check if we got any results
	if len(result) == 0 {
		return "", fmt.Errorf("procedure %s not found", procName)
	}

	// Get the DDL from the result
	ddl, ok := result[0]["DDL"].(string)
	if !ok || ddl == "" {
		return "", fmt.Errorf("empty procedure definition for %s", procName)
	}

	// Return the procedure DDL
	return fixedEnd(removeEDITIONABLE(ddl), true), nil
}

func (s *oracleSql) getCreateFunctionSql(j DatabaseClient, database, funcName string) (string, error) {
	funcName = ConvertReservedKeywords(funcName)
	// Query to get the function definition from Oracle data dictionary
	query := `
		SELECT DBMS_METADATA.GET_DDL('FUNCTION', :funcName, :schema) as ddl
		FROM DUAL
	`

	// Execute the query with parameters
	params := map[string]interface{}{
		"funcName": strings.ToUpper(funcName),
		"schema":   strings.ToUpper(database),
	}

	// Query the database
	result, err := j.NQuery(query, params)
	if err != nil {
		return "", err
	}

	// Check if we got any results
	if len(result) == 0 {
		return "", fmt.Errorf("function %s not found", funcName)
	}

	// Get the DDL from the result
	ddl, ok := result[0]["DDL"].(string)
	if !ok || ddl == "" {
		return "", fmt.Errorf("empty function definition for %s", funcName)
	}
	ddl = strings.TrimSpace(ddl)
	// Return the function DDL
	return fixedEnd(removeEDITIONABLE(ddl), true), nil
}

func (s *oracleSql) GetCreateEventSql(j DatabaseClient, database, eventName string) (string, error) {
	eventName = ConvertReservedKeywords(eventName)
	// Oracle doesn't have direct equivalents to MySQL events
	// The closest equivalent would be DBMS_SCHEDULER or DBMS_JOB
	// For now, we'll return a helpful error message
	return "", fmt.Errorf("Oracle does not support events in the same way as MySQL. "+
		"Consider using DBMS_SCHEDULER or DBMS_JOB for scheduled tasks. "+
		"Requested event: %s", eventName)
}
